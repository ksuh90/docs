---
title: Connection management
metaTitle: Connection management (Guide)
metaDescription: 'How to approach connection management with Prisma Client in serverless and PaaS applications.'
tocDepth: 2
---

<TopBlock>

Databases can handle a limited number of concurrent connections. Each connection requires RAM, which means that simply increasing the connection limit without scaling the database:

* ‚úî might allow more processes to connect _but_
* ‚úò significantly affects database **performance**

The way your application **manages connections** also impacts performance. This guide describes how to approach connection management in [serverless environments](#serverless-environments-faas) and [long-running processes](#long-running-processes-paas).

</TopBlock>

## Long-running processes (PaaS)

Examples of long-running processes include Node.js applications hosted on a PaaS service like Heroku. Use the following checklist as a guide to connection management in PaaS environments:

- ‚òê Tune the [connection limit](#recommended-connection-limit)
- ‚òê Make sure you have [**one** global instance of `PrismaClient`](#prismaclient-in-long-running-applications)

### Recommended connection limit

The recommended connection limit for long-running processes is the **default connection limit** (`num_physical_cpus * 2 + 1`) √∑ **number of application instances**.

If you have **one** application instances:

* The default connection limit applies by default (`num_physical_cpus * 2 + 1`) - you do not need to set the `connection_limit` parameter.
* You can optionally [tune the pool size](#optimizing-the-connection-pool).

If you have **multiple** application instances:

* You must **manually** [set the `connection_limit` parameter](../../../concepts/components/prisma-client/working-with-prismaclient/connection-pool#setting-the-connection-limit) <span class="concept"></span>. For example, if your calculated connection limit is _10_ and you have _2_ instances of your app, the connection limit should be **no more than _5_**.
* You can optionally [tune the pool size](#optimizing-the-connection-pool).

### <inlinecode>PrismaClient</inlinecode> in long-running applications

In **long-running** applications, we recommend that you:

* ‚úî Create **one** instance of `PrismaClient` and re-use it across your application
* ‚úî Assign `PrismaClient` to a global variable _in dev environments only_ to [prevent hot reloading from creating new instances](#prevent-hot-reloading-from-creating-new-instances-of-prismaclient)

To re-use a single instance, create a module that exports a `PrismaClient` object:

```ts file=client.ts
import { PrismaClient } from "@prisma/client"

let prisma = new PrismaClient() 

export default prisma
```

The object is [cached](https://nodejs.org/api/modules.html#modules_caching) the first time the module is imported. Subsequent requests return the cached object rather than creating a new `PrismaClient`:

```ts file=app.ts
import prisma from './client'

async function main() {
  const allUsers = await prisma.user.findMany();
}

main();
```

#### Do not explicitly `$disconnect()`

You [do not need to explicitly `$disconnect()`](../../../concepts/components/prisma-client/working-with-prismaclient/connection-management#calling-disconnect-explicitly) <span class="concept"></span> in the context of a long-running application that is continuously serving requests. Opening a new connection takes time and can slow down your application if you disconnect after each query.

#### Prevent hot reloading from creating new instances of `PrismaClient`

Frameworks like [Next.js](https://nextjs.org/) support hot reloading of changed files, which enables you to see changes to your application without restarting. However, if the framework refreshes the module responsible for exporting `PrismaClient`, this can result in **additional, unwanted instances of `PrismaClient` in a development environment**.

As a workaround, you can store `PrismaClient` as a global variable in development environments only, as global variables are not reloaded:

```ts file=client.ts
import { PrismaClient } from "@prisma/client";

// add prisma to the NodeJS global type
interface CustomNodeJsGlobal extends NodeJS.Global {
    prisma: PrismaClient;
}

// prevent multiple instances of Prisma Client in development
declare const global: CustomNodeJsGlobal;
const prisma = global.prisma || new PrismaClient();
if (process.env.NODE_ENV === "development") global.prisma = prisma;
export default prisma;
  prisma = global.prisma
}

export default prisma
```

The way that you import and use the client does not change:

```ts file=app.ts
import prisma from './client'

async function main() {
    const allUsers = await prisma.user.findMany();
}

main();
```

## Serverless environments (FaaS)

Examples of serverless environments include Node.js functions hosted on AWS Lambda. Use the following checklist as a guide to connection management in serverless environments:

- ‚òê [Set connection limit](#recommended-connection-limit-1) based on whether you have an external connection pooler
- ‚òê Optionally [tune the pool size](#optimizing-the-connection-pool) if you are using an external connection pooler
- ‚òê [Instantiate `PrismaClient` outside the handler](#instantiate-prismaclient-outside-the-handler) and do not explicitly `$disconnect()`
- ‚òê Configure [function concurrency](#concurrency-limits) and handle [idle connections](#zombie-connections)

### The serverless challenge

In a serverless environment, each function creates **its own instance** of `PrismaClient`, and each client instance has its own connection pool. 

Consider the following example, where a single AWS Lambda function uses `PrismClient` to connect to a database. The `connection_limit` is **3**:

![An AWS Lambda function connecting to a database.](./serverless-connections.png)

A traffic spike causes AWS Lambda to spawn two additional lambdas to handle the increased load. Each lambda creates an instance of `PrismaClient`, each with a `connection_limit` of **3**, which results in a maximum of **9** connections to the database:

![Three AWS Lambda function connecting to a database.](./serverless-connections-2.png)
 
200 _concurrent functions_ (and therefore 600 possible connections) responding to a traffic spike üìà can exhaust the database connection limit very quickly.

1. Start by [setting the `connection_limit` is set to `1`](#recommended-connection-limit-1)
2. If a lower connection limit is not enough, consider using an [external connection pooler like PgBouncer](#external-connection-poolers)

### Recommended connection limit

The recommended connection limit in serverless environments depends on whether you are using an [external connection pooler](#external-connection-poolers).

#### Without an external connection pooler

We recommend that you set the `connection_limit` to **1** if you are **not** using an external connection pooler. Each incoming request starts a short-lived Node.js process, and many concurrent functions with a high `connection_limit` can quickly **exhaust the _database_ connection limit** during a traffic spike.

The following example demonstrates how to set the `connection_limit` to 1 in your connection string:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

  ```
  postgresql://USER:PASSWORD@HOST:PORT/DATABASE?connection_limit=1
  ```

</tab>
<tab>

  ```
  mysql://USER:PASSWORD@HOST:PORT/DATABASE?connection_limit=1
  ```

</tab>
</TabbedContent>

#### With an external connection pooler

If you are using an external connection pooler, use the default connection limit (`num_physical_cpus * 2 + 1`) as a starting point and then [tune the pool size](#optimizing-the-connection-pool). The external connection pooler prevents a traffic spike from overwhelming the database.

### <inlinecode>PrismaClient</inlinecode> in serverless environments

#### Instantiate `PrismaClient` outside the handler

Instantiate `PrismaClient` [outside the scope of the function handler](https://github.com/prisma/e2e-tests/blob/5d1041d3f19245d3d237d959eca94d1d796e3a52/platforms/serverless-lambda/index.ts#L3) to increase the chances of reuse. As long as the handler remains 'warm' (in use), the connection is potentially reusable:

```ts highlight=3;normal
import { PrismaClient, Prisma } from '@prisma/client'

const client = new PrismaClient()

export async function handler() {
    /* ... */
}
```

#### Do not explicitly <inlinecode>$disconnect()</inlinecode>

You [do not need to explicitly `$disconnect()`](../../../concepts/components/prisma-client/working-with-prismaclient/connection-management#calling-disconnect-explicitly) <span class="concept"></span> at the end of a function, as there is a possibility that the container might be reused. Opening a new connection takes time and slows down your function's ability to process requests.

### Other serverless considerations

#### Container reuse

There is no guarnatee that subsequent nearby invocations of a function will hit the same container - for example, AWS can choose to create a new container at any time.

Code should assume the container to be stateless and create a connection only if it does not exist - Prisma Client JS already implements this logic.

#### Zombie connections

Containers that are marked to be removed and are not being reused still keep a connection open and can stay in that state for some time (unknown and not documented from AWS). This can lead to sub-optimal utilization of the DB connections.

Potential solutions<sup>1, 2</sup> include:

* Using a lower idle connection timeout.
* Cleaning up the idle connections in a separate service.

<sup>
  1. Note that these are recommendations and not best practices. These would vary from system to
  system.
</sup>
<br />
<sup>
  2.{' '}
  <a href="https://github.com/jeremydaly/serverless-mysql">
    <inlineCode>serverless-mysql</inlineCode>
  </a>{' '}
  is a library that implements this idea.
</sup>

#### Concurrency limits

Depending on your serverless concurrency limit (the number of serverless functions running in parallel), you might still exhaust your database's connection limit. This can happen when too many functions are invoked concurrently, each with its own connection pool, which eventually exhausts the database connection limit. To prevent this, you can [set your serverless concurrency limit](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html) to a number lower than the connection limit of your database (as you might want to be able to connect from another client for other purposes).

## Optimizing the connection pool

If the query engine cannot [process a query in the queue before the time limit](../../../concepts/components/prisma-client/working-with-prismaclient/connection-pool#how-the-connection-pool-works) <span class="concept"></span>, you will see connection pool timeout exceptions in your log. A connection pool timeout can occur if:

* Many users are accessing your app simultanously
* You send a large number of queries in parallel (for example, using `await Promise.all()`)

If you consistently experience connection pool timeouts after configuring the recommended connection limit, you can further tune the `connection_limit` and `pool_timeout` parameters.

### Increasing the connection limit

Increasing the connection limit allows the query engine to process a larger number of queries in parallel. Be aware that your database must be able to support the increased number of concurrent connections, otherwise you will **exhaust the connection limit**.

To increase the connection limit, manually set the `connection_limit` to a higher number:

```prisma
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=40"
}
```

### Increasing the pool timeout

Increasing the pool timeout gives the query engine more time to process queries in the queue. You might consider this approach in the following scenario:

* You have already increased the `connection_limit`.
* You are confident that the queue will not grow beyond a certain size, otherwise **you will eventually run out of RAM**.

To incrase the pool timeout, set the `pool_timeout` parameter to a value larger than the default (10 seconds):

```prisma
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=20"
}
```

### Disabling the pool timeout

Disabling the pool timeout prevents the query engine from throwing an exception and allows the queue to build up. You might consider this approach in the following scenario:

* You are submitting a large number of queries for a limited time - for example, as part of a job to import or update every customer in your database.
* You have already increased the `connection_limit`.
* You are confident that the queue will not grow beyond a certain size, otherwise **you will eventually run out of RAM**.

To disable the pool timeout, set the `pool_timeout` parameter to `0`:

```prisma
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=0"
}
```

## External connection poolers

Connection poolers like [PgBouncer](https://www.pgbouncer.org/) prevents your application from exhausting the database's connection limit.

### PgBouncer

PostgreSQL only supports a certain amount of concurrent connections, and this limit can be reached quite fast when the service usage goes up ‚Äì especially in [serverless environments](#serverless-environments-faas).

PgBouncer holds a connection pool to the database and proxies incoming client connections by sitting between Prisma Client and the database. This reduces the number of processes a database has to handle at any given time. PgBouncer passes on a limited number of connections to the database and queues additional connections for delivery when space becomes available.

To use PgBouncer, see: [Configure Prisma Client with PgBouncer](configure-pg-bouncer)
